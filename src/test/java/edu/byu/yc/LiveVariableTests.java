package edu.byu.yc;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.jdt.core.dom.ASTNode;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class LiveVariableTests {

    private static Logger logger = LoggerFactory.getLogger(LiveVariableTests.class);

    /**
     * This test is included to give you a starting point. You will need
     * additional tests in order to create mutation coverage.
     */
    @Test
    public void emptyCFGTest() {
        CFG cfg = Mockito.mock(CFG.class);
        Node exit = ExitNode.getInstance();
        Mockito.when(cfg.exitNode()).thenReturn(exit);
        Mockito.when(cfg.successors(Mockito.any(ASTNode.class)))
                .thenReturn(new HashSet<>());
        Mockito.when(cfg.predecessors(Mockito.any(ASTNode.class)))
                .thenReturn(new HashSet<>());

        LiveVariableAnalysis lva = new LiveVariableAnalyzer(cfg);
        Map<Node, Set<String>> result = lva.analyze();
        assertEquals(0, result.keySet().size());
    }

    /**
     * This test mimics a simple CFG program to see that it is analyzed correctly
     * Program is generated by generateNodesForSimpleCFG.
     */
    @Test
    public void simpleCFGTest() {
        CFG cfg = Mockito.mock(CFG.class);
        Node entry = EntryNode.getInstance();
        Node exit = ExitNode.getInstance();
        List<Node> simpleCFGNodes = generateNodesForSimpleCFG();
        //Get the nodes of the CFG
        Node node1 = simpleCFGNodes.get(0);
        Node node2 = simpleCFGNodes.get(1);
        Node node3 = simpleCFGNodes.get(2);

        //Entry Node
        Mockito.when(cfg.predecessors(exit)).thenReturn(null);
        Mockito.when(cfg.successors(entry)).thenReturn(getSingleNodeAsSet(node1));

        //Node1
        Mockito.when(cfg.predecessors(node1)).thenReturn(getSingleNodeAsSet(entry));
        Mockito.when(cfg.successors(node1)).thenReturn(getSingleNodeAsSet(node2));

        //Node2
        Mockito.when(cfg.predecessors(node2)).thenReturn(getSingleNodeAsSet(node1));
        Mockito.when(cfg.successors(node2)).thenReturn(getSingleNodeAsSet(node3));

        //Node3
        Mockito.when(cfg.predecessors(node3)).thenReturn(getSingleNodeAsSet(node2));
        Mockito.when(cfg.successors(node3)).thenReturn(getSingleNodeAsSet(exit));

        //Exit Node
        Mockito.when(cfg.exitNode()).thenReturn(exit);
        Mockito.when(cfg.successors(exit)).thenReturn(null);
        Mockito.when(cfg.predecessors(exit)).thenReturn(getSingleNodeAsSet(node3));

        LiveVariableAnalysis lva = new LiveVariableAnalyzer(cfg);
        Map<Node, Set<String>> result = lva.analyze();

        logger.info("Analyzer results: {}", result);

        //Expects 4 nodes since there are 3 nodes + 1 Entry node, do not count exit node
        assertEquals(4, result.keySet().size());


        //Test Node 3 has correct Live Nodes
        Set<String> expectedNode3Set = new HashSet<>();
        expectedNode3Set.add("b");
        expectedNode3Set.add("c");
        assertEquals(expectedNode3Set, result.get(node3));

        //Test Node 2 has correct Live Nodes
        Set<String> expectedNode2Set = new HashSet<>();
        expectedNode2Set.add("b");
        assertEquals(expectedNode2Set, result.get(node2));

        //Test Node 1 has correct Live Nodes
        assertEquals(new HashSet<String>(), result.get(node1));

        //Test Entry Node has correct Live Nodes
        assertEquals(new HashSet<String>(), result.get(entry));

    }

    /**
     * This test mimics a more complex CFG and sees that the LiveVariableAnalyzer works as
     * expected
     */
    @Test
    public void complexCFGTest() {
        CFG cfg = Mockito.mock(CFG.class);
        Node entry = EntryNode.getInstance();
        Node exit = ExitNode.getInstance();
        List<Node> simpleCFGNodes = generateNodesForSimpleCFG();
        //Get the nodes of the CFG
        Node node1 = simpleCFGNodes.get(0);
        Node node2 = simpleCFGNodes.get(1);
        Node node3 = simpleCFGNodes.get(2);

        //Entry Node
        Mockito.when(cfg.predecessors(exit)).thenReturn(null);
        Mockito.when(cfg.successors(entry)).thenReturn(getSingleNodeAsSet(node1));

        //Node1
        Mockito.when(cfg.predecessors(node1)).thenReturn(getSingleNodeAsSet(entry));
        Mockito.when(cfg.successors(node1)).thenReturn(getSingleNodeAsSet(node2));

        //Node2
        Mockito.when(cfg.predecessors(node2)).thenReturn(getSingleNodeAsSet(node1));
        Mockito.when(cfg.successors(node2)).thenReturn(getSingleNodeAsSet(node3));

        //Node3
        Mockito.when(cfg.predecessors(node3)).thenReturn(getSingleNodeAsSet(node2));
        Mockito.when(cfg.successors(node3)).thenReturn(getSingleNodeAsSet(exit));

        //Exit Node
        Mockito.when(cfg.exitNode()).thenReturn(exit);
        Mockito.when(cfg.successors(exit)).thenReturn(null);
        Mockito.when(cfg.predecessors(exit)).thenReturn(getSingleNodeAsSet(node3));

        LiveVariableAnalysis lva = new LiveVariableAnalyzer(cfg);
        Map<Node, Set<String>> result = lva.analyze();

        logger.info("Analyzer results: {}", result);

        //Expects 4 nodes since there are 3 nodes + 1 Entry node, do not count exit node
        assertEquals(4, result.keySet().size());


        //Test Node 3 has correct Live Nodes
        Set<String> expectedNode3Set = new HashSet<>();
        expectedNode3Set.add("b");
        expectedNode3Set.add("c");
        assertEquals(expectedNode3Set, result.get(node3));

        //Test Node 2 has correct Live Nodes
        Set<String> expectedNode2Set = new HashSet<>();
        expectedNode2Set.add("b");
        assertEquals(expectedNode2Set, result.get(node2));

        //Test Node 1 has correct Live Nodes
        assertEquals(new HashSet<String>(), result.get(node1));

        //Test Entry Node has correct Live Nodes
        assertEquals(new HashSet<String>(), result.get(entry));

    }

    private Set<Node> getSingleNodeAsSet(Node node) {
        Set<Node> nodes = new HashSet<>();
        nodes.add(node);
        return nodes;
    }




    /**
     * Generates nodes for the following simple program
     * //entry
     * b = 3         //node1
     * c = 5         //node2
     * a = f(b * c)  //node3
     * //exit
     */
    private List<Node> generateNodesForSimpleCFG() {
        List<Node> nodes = new ArrayList<>();
        Node node1 = new Node() {
            @Override
            public Set<String> getDefs() {
                String b = "b";
                Set<String> defs = new HashSet<>();
                defs.add(b);
                return defs;
            }

            @Override
            public Set<String> getUses() {
                return new HashSet<>();
            }

            @Override
            public String toString() {
                return "node1";
            }
        };

        Node node2 = new Node() {
            @Override
            public Set<String> getDefs() {
                String c = "c";
                Set<String> defs = new HashSet<>();
                defs.add(c);
                return defs;
            }

            @Override
            public Set<String> getUses() {
                return new HashSet<>();
            }

            @Override
            public String toString() {
                return "node2";
            }
        };

        Node node3 = new Node() {
            @Override
            public Set<String> getDefs() {
                String a = "a";
                Set<String> defs = new HashSet<>();
                defs.add(a);
                return defs;
            }

            @Override
            public Set<String> getUses() {
                Set<String> uses = new HashSet<>();
                uses.add("b");
                uses.add("c");
                return uses;
            }

            @Override
            public String toString() {
                return "node3";
            }
        };

        nodes.add(node1);
        nodes.add(node2);
        nodes.add(node3);

        return nodes;

    }

}
